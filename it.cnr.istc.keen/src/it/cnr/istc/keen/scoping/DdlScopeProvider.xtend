/*
 * generated by Xtext 2.10.0
 */
package it.cnr.istc.keen.scoping

import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import it.cnr.istc.keen.ddl.SVComponentDecision
import it.cnr.istc.keen.ddl.DdlPackage
import org.eclipse.xtext.EcoreUtil2
import it.cnr.istc.keen.ddl.TimelineSynchronization
import it.cnr.istc.keen.ddl.Component
import org.eclipse.xtext.scoping.Scopes
import it.cnr.istc.keen.ddl.InstantiatedComponentDecision
import it.cnr.istc.keen.ddl.VarRef
import it.cnr.istc.keen.ddl.ParValue
import it.cnr.istc.keen.ddl.TransitionConstraint
import it.cnr.istc.keen.ddl.Synchronization
import it.cnr.istc.keen.ddl.EnumLiteral
import it.cnr.istc.keen.ddl.RValue
import it.cnr.istc.keen.ddl.Domain
import it.cnr.istc.keen.ddl.TemporalConstraint
import it.cnr.istc.keen.ddl.ProblemTemporalConstraint
import it.cnr.istc.keen.ddl.Problem
import it.cnr.istc.keen.ddl.ComponentDecisionType

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class DdlScopeProvider extends AbstractDdlScopeProvider {

	override getScope(EObject context, EReference reference)
	{
		/*
		 *  The value of a component decision reference, used in synchronizations (a) or
		 * instantiated component decisions (b). It is a link to a component decision type
		 * Example:
		 *   a) VALUE >>>RemoveTopCover(?piece)<<<
		 *   b) Human.operator.>>>_Unscrew(?piece0, ?location0)<<<;
		 */
		if (context instanceof SVComponentDecision
			&& reference == DdlPackage.Literals.SV_COMPONENT_DECISION__VALUE)
		{
			//are we in a instantiated component decision? (<timeline>.<reference>)
			val icd = EcoreUtil2.getContainerOfType(context,InstantiatedComponentDecision);
			var timeline = if (icd != null) icd.timeline;
			if (timeline == null)
			{
				//no, let's see if we are in a timeline synchronization (SYNCHRONIZE <timeline>)
				val synchro = EcoreUtil2.getContainerOfType(context,TimelineSynchronization);
				timeline = if (synchro != null) synchro.timeline;
			}
			//The component where the timeline is contained
			val component = if (timeline != null) EcoreUtil2.getContainerOfType(timeline,Component);
			//Its type definition
			val type = if (component != null) component.type;
			if (type!=null)
			{
				//Scope is made of all component decisions of the type
				val types = EcoreUtil2.getAllContentsOfType(type,ComponentDecisionType);
				return Scopes.scopeFor(types);
			}
		}

		/*
		 * Variable references (es: ?myVariable) are bounded to parameters definition
		 * (ParValue), whose scope is:
		 * - A synchronization block of a timeline (VALUE ...)
		 * - A transition constraint in a component type definition (VALUE ... MEETS)
		 * - A Problem block
		 */
		if (context instanceof VarRef
			&& reference == DdlPackage.Literals.VAR_REF__REF)
		{
			//Synchronization block: VALUE <cd> { <statements> }
			var container = EcoreUtil2.getContainerOfType(context,Synchronization) as EObject;
			//else, Transition constraint block: VALUE <cd> MEETS { <statements> }
			if (container == null)
				container = EcoreUtil2.getContainerOfType(context,TransitionConstraint) as EObject;
			//else, Problem block
			if (container == null)
				container = EcoreUtil2.getContainerOfType(context,Problem) as EObject;
			if (container!=null)
			{
				//Scope is made of all ParValues of the selected block
				val vars = EcoreUtil2.getAllContentsOfType(container,ParValue);
				return Scopes.scopeFor(vars);				
			}
		}
		
		/*
		 * Enumeration literal: it is defined inside an enumeration, inside a domain
		 */
		if (context instanceof RValue &&
			reference == DdlPackage.Literals.RVALUE__ENUMERATION)
		{
			var domain = EcoreUtil2.getContainerOfType(context,Domain);
			if (domain == null)
			{
				val problem = EcoreUtil2.getContainerOfType(context,Problem);
				if (problem != null)
					domain = problem.domain;
			}
			if (domain!=null)
			{
				//Scope is made of all enum literals defined in the domain
				val enumLiterals = EcoreUtil2.getAllContentsOfType(domain,EnumLiteral);
				return Scopes.scopeFor(enumLiterals);				
			}
		}
		
		/*
		 * Instantiated component decisions in temporal constraint references
		 * (from and to).
		 * Example:
		 * - cd0 STARTS cd1
		 */
		if (context instanceof TemporalConstraint &&
			(reference == DdlPackage.Literals.TEMPORAL_CONSTRAINT__FROM ||
				reference == DdlPackage.Literals.TEMPORAL_CONSTRAINT__TO))
		{
			//The synchronization block (VALUE ... {}) where we are in 
			val block = EcoreUtil2.getContainerOfType(context,Synchronization);
			if (block != null)
			{
				//Scope is made of all InstantiatedComponentDecisions of the selected block
				val icds = EcoreUtil2.getAllContentsOfType(block,InstantiatedComponentDecision);
				return Scopes.scopeFor(icds);				
			}
		}
		
		/*
		 * Same as above, but for ProblemTemporalConstraint instead of "normal" one
		 */
		if (context instanceof ProblemTemporalConstraint &&
			(reference == DdlPackage.Literals.PROBLEM_TEMPORAL_CONSTRAINT__FROM ||
				reference == DdlPackage.Literals.PROBLEM_TEMPORAL_CONSTRAINT__TO))
		{
			val block = EcoreUtil2.getContainerOfType(context,Problem);
			if (block != null)
			{
				val icds = EcoreUtil2.getAllContentsOfType(block,InstantiatedComponentDecision);
				return Scopes.scopeFor(icds);				
			}
		}
		
		//Else, use the default mechanism
		return super.getScope(context,reference);
	}
}
